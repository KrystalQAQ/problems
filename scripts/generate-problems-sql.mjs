import fs from 'node:fs'
import path from 'node:path'

function sqlStringLiteral(value) {
  const s = String(value ?? '')
  return `'${s.replace(/'/g, "''")}'`
}

function parseAnswerChoices(raw) {
  const letters = raw
    .replace(/\s+/g, '')
    .split(/[、,，/|]/g)
    .flatMap((part) => part.split(''))
    .map((c) => c.toUpperCase())
    .filter((c) => /^[A-Z]$/.test(c))
  return [...new Set(letters)]
}

function parseProblems(text) {
  const lines = text.replace(/\r\n/g, '\n').split('\n')

  let currentSection = null
  /** @type {Array<any>} */
  const problems = []
  /** @type {any} */
  let current = null
  let lastOptionKey = null

  function finishCurrent() {
    if (!current) return
    if (!current.stem?.trim()) {
      current = null
      lastOptionKey = null
      return
    }
    if (!current.answerRaw?.trim()) {
      current = null
      lastOptionKey = null
      return
    }
    problems.push(current)
    current = null
    lastOptionKey = null
  }

  for (const lineRaw of lines) {
    const line = lineRaw.trimEnd()
    if (!line.trim()) continue

    const sec = line.match(/^第.+?部分：(.+)$/)
    if (sec) {
      finishCurrent()
      currentSection = sec[1].trim()
      continue
    }

    const q = line.match(/^(\d+)\.(.+)$/)
    if (q) {
      finishCurrent()
      current = {
        section: currentSection ?? '未知',
        sourceNo: Number(q[1]),
        stem: q[2].trim(),
        options: {},
        answerRaw: null,
      }
      continue
    }

    if (!current) continue

    const opt = line.match(/^\s*(?:·\s*)?([A-Z])\.(.+)$/)
    if (opt) {
      const key = opt[1].toUpperCase()
      current.options[key] = opt[2].trim()
      lastOptionKey = key
      continue
    }

    const ans = line.match(/^(?:参考答案|答案)[:：]\s*(.+)$/)
    if (ans) {
      current.answerRaw = ans[1].trim()
      continue
    }

    if (lastOptionKey) {
      current.options[lastOptionKey] = `${current.options[lastOptionKey]}\n${line.trim()}`
      continue
    }

    current.stem = `${current.stem}\n${line.trim()}`
  }

  finishCurrent()

  return problems.map((p) => {
    let questionType = 'single_choice'
    if (p.section.includes('多项')) questionType = 'multiple_choice'
    if (p.section.includes('填空')) questionType = 'fill_blank'

    const hasOptions = Object.keys(p.options).length > 0

    /** @type {any} */
    let answer = null
    if (questionType === 'fill_blank' || !hasOptions) {
      answer = { text: p.answerRaw }
    } else {
      answer = { choices: parseAnswerChoices(p.answerRaw) }
    }

    return {
      section: p.section,
      sourceNo: p.sourceNo,
      questionType,
      stem: p.stem,
      options: hasOptions ? p.options : null,
      answer,
      source: 'problems.txt',
    }
  })
}

function toSeedSql(rows) {
  const header = `-- Generated by scripts/generate-problems-sql.mjs
-- Source: problems.txt

begin;

`

  const statements = rows.map((r) => {
    const optionsSql = r.options ? sqlStringLiteral(JSON.stringify(r.options)) + '::jsonb' : 'null'
    const answerSql = sqlStringLiteral(JSON.stringify(r.answer)) + '::jsonb'
    return `insert into public.problems (section, source_no, question_type, stem, options, answer, source)
values (${sqlStringLiteral(r.section)}, ${r.sourceNo}, ${sqlStringLiteral(r.questionType)}, ${sqlStringLiteral(
      r.stem,
    )}, ${optionsSql}, ${answerSql}, ${sqlStringLiteral(r.source)})
on conflict (section, source_no) do update set
  question_type = excluded.question_type,
  stem = excluded.stem,
  options = excluded.options,
  answer = excluded.answer,
  source = excluded.source;`
  })

  const footer = `

commit;
`

  return header + statements.join('\n\n') + footer
}

const repoRoot = process.cwd()
const inputPath = path.join(repoRoot, 'problems.txt')
const outputPath = path.join(repoRoot, 'supabase', 'seed_problems.sql')

const inputText = fs.readFileSync(inputPath, 'utf8')
const rows = parseProblems(inputText)
const sql = toSeedSql(rows)

fs.mkdirSync(path.dirname(outputPath), { recursive: true })
fs.writeFileSync(outputPath, sql, 'utf8')

console.log(`OK: parsed ${rows.length} problems -> ${path.relative(repoRoot, outputPath)}`)
